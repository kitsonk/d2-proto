# tmpl

**tmpl** is a module and plug-in which allows for templating of DOM structures, with support for logic and variable
substitution.  The templates can be generated both on the client side and as an HTML string on the server side.

## Usage

There are two main ways of using the `tmpl` module.  One way is as an AMD plug-in.  This expects a plugin argument that
is string in the templating format.  This will return an instance of a `Template` object which allows the generation of
the template.

The second is directly as a module which allows the creation of instances of `Template` objects.  This allows for the
management of many different templates.

The templates can be pre-compiled at build time into an optimised JavaScript object which then can be stored as part of
the build, therefore not needing to load the template.  There are also functions which allow the serialization of the
templates so they can be more optimally stored as well as the ability to take the internal format and output an
originally compatible template.

## Template Format

The basic concept of the the templating format supported by `tmpl` is to leverage CSS selectors to generate the DOM
elements.  There is also support for variables and logic operators.  If you wanted to generate a table, it would look
something like this:

```
table.foo
	thead
		tr
			th[content=Column A]
			th[content=Column B]
			th[content=Column C]
	tbody
		tr
			td[content=a]
			td[content=b]
			td[content=c]
		tr
			td[content=d]
			td[content=e]
			td[content=f]
```

Which would output:

```html
<table class="foo">
	<thead>
		<tr>
			<th>Column A</th>
			<th>Column B</th>
			<th>Column C</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>a</td>
			<td>b</td>
			<td>c</td>
		</tr>
		<tr>
			<td>d</td>
			<td>e</td>
			<td>f</td>
		</tr>
	</tbody>
</table>
```

Each selector is on a new line and the leading whitespace is significant in that each further indentation indicates that
it is the child of the preceding line and the same indentation a sibling.

### Selectors

**TODOC**

### Variables

Variables can be used in templates using special markup and then are processed either at generation or compile time.
The name of the variable should match the name of the property and the "dot" notation allows deep property reference.

Based on the following object passed as an argument:

```js
{
	foo: 'bar',
	baz: [1, 2, 3],
	qat: {
		bar: 1,
		baz: 2
	}
}
```

The following would be valid variable names in the template:

```
${foo}
${baz}
${qat.bar}
${qat.baz}
```

### Logic

There are some basic logic operators which can be used in templates.  If the arguments for the logic are available at
compile time, they logic resolved at compile time.  Otherwise the logic is resolved at generation time.

Any variables that are "created" by these logic operators are then "scoped" within the whole template.  This means you
can use their values outside of the block there were generated by, but it does also "overwrite" any other values of
the same name within the variable scope of the template.

Variables within the lines that start with a logic keyword instead of a selector do not use the `${}` notation.

#### each

Used to iterate over the properties of an object or the elements of an array.

If you wanted to output the elements of an array as a list box, your `vars` would look like this:

```js
{ foo: [ 1, 2, 3 ]}
```

And your template would look like this:

```
ul
	each i in foo
		li[content=${i}]
```

Which would result in:

```html
<ul>
	<li>1</li>
	<li>2</li>
	<li>3</li>
</ul>
```

If you wanted to iterate over the properties of an object, your `vars` would look like this:

```js
{ foo: { bar: 1, baz: 2, qat: 3} }
```

And your template would look like this:

```
ul
	each value, key in foo
		li[content=${key}:${value}]
```

Which would result in:

```html
<ul>
	<li>bar:1</li>
	<li>baz:2</li>
	<li>qat:3</li>
</ul>
```

#### if, elseif, else, unless

Logic branching can be expressed in the templates via the keywords `if`, `elseif`, `else` or `unless`.  With `if`,
`elseif` and `unless` the logic condition after the keyword is used to figure out if that branch is used.  The logic
expressions are the same as they would be in native JavaScript.  The keyword `unless` is simply a "shortcut" to the
equivalent of `if !(expression)`.

For example, if you wanted to provide two different messages based on a condition, you would do something like this:

```
div.foo
	if err
		div.error[content=${err.msg}]
	else
		div.ok[content=Good to go]
```

If you wanted to check the status of a user, you could do something like this:

```
div.foo
	if user.class === 'admin'
		div[content=Welcome Admin]
	elseif user.class === 'user'
		div[content=You are a normal user]
	else
		div[content=I don't know what kind of user you are]
```

And if you wanted to do something unless a condition is met, you could do something like this:

```
div.foo
	unless user.loggedIn
		button[type=button][content=Log In]
```

#### switch, case, default

Complex branch logic can be expressed in templates via the keywords `switch`, `case` and `default`.  For example if you
wanted to adjust the display based on the type of user, you could do something like this:

```
div.foo
	switch user.class
		case 'admin'
			div.admin[content=You are an Admin]
		case 'user'
			div.user[content=You are a user]
		default
			div.unknown[content=You are unknown]
```

## API

### Template

If used as a plugin, an instance of `Template` is created loaded with the supplied template argument, which becomes
the target of further actions.

### Template.generate(node, vars)

This takes the template that has been loaded, compiles it and then creates the DOM.  If `node` is passed, the template
is created using that node as a parent.  The `vars` argument is an optional argument used for looking up any named
variables encountered in the template.

### Template.compile(text, vars)

This processes and compiles the template.  The `text` argument is optional.  If supplied it is a `tmpl` formatted string
that will replace any existing template.  The `vars` argument is an optional argument used for looking up any named
variables encountered in the template.  Using `vars` at compile time will mean they are statically built into the
compiled template and will not be utilised during generation time.

### Template.fromJson(text)

Take a JSON string that represents a compiled template and make it the current template.

### Template.fromTmpl(text)

Take a `tmpl` formatted string and make it the current tempalte.

### Template.toString(vars)

Output a JSON string the represents the template.  Optionally uses the `vars` argument to statically bind any variables
and process logic before outputting the string.

### Template.toTmpl(vars)

Output a string formatted as a `tmpl` template.  Optionally uses the `vars` argument to statically bind any variables
and process logic before outputting the string.
